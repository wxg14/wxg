#include "sender.h"
//#include "types.h"
//#include "Ini.h"
//#include "common.h"
//#include "MPU6050TEST.h"
#include "quatutils.h"
#include "common.h"
#include "CoolLog.h"
#include "qconsts.h"
//#include "FOgreWidget.h"
#include "osg/Point"
#include "mnv.h"
#include <string.h>
#include <ctime>
#include<Winsock2.h> 
#include <QMessageBox>
#include <QString.h>
#include <qsettings.h>
#include <qdatetime.h>
#include <tchar.h>
#include <assert.h>

float Myntohl(float val)
{
	union{
		UINT32 i;
		float f;
	}st;
	st.f = val;
	st.i = ntohl(st.i);
    return st.f;
}
void RecvDatafunc(char* pBuf, DWORD dwCount, char* pszIP, WORD wPort)
{
//	PRINTF("test");
	if (strcmp(pBuf,"Cali") == 0)
	{
		Sender::CaliMask = true;
		//PRINTF("Zero command");
		//SendMessage(GetCurrentThreadId(), RESETATTMSG, 0, 0);
		//PostMessage(Sender::Mainhandle, RESETATTMSG, 0, 0);
	}
// CEXIT 0x01
// CCALI 0x02
// CSAVE 0x03
// CSETDISRATE 0x04
// CADDIPANDPORT 0x05
	byte * pdata = (byte*)pBuf;
	if ((pdata[0] == 0xB4) && (pdata[1] ==0x4B))
	{
		int nlen = pdata[2];
		int ncommand = pdata[3];
		if (ncommand == 0x01)
		{
            Sender::ExitMask = true;
			//PRINTF("Receive Exit Command");
		}
		else if (ncommand == 0x02)
		{
            Sender::CaliMask = true;
			//PRINTF("Receive Calibration Command");
		}
		else if (ncommand == 0x03)
		{
			Sender::SaveMask = true;
			//PRINTF("Receive Save Command");
		}
		else if (ncommand == 0x04)
		{
			int nrate = (pdata[7]<<24) + (pdata[6]<<16) + (pdata[5]<<8) + pdata[4];
			Sender::m_disrate = *((float*)(&nrate));
			Sender::SetDisRateMask = true;
			//PRINTF("Receive SetDisRate Command");
		}
		else if (ncommand == 0x05)
		{
			int nport = (pdata[7]<<24) + (pdata[6]<<16) + (pdata[5]<<8) + pdata[4];
            char ip[128];
			QString newip;
			int iplen = pdata[2] - 7;
			for (int i=0; i<iplen; i++)
			{
				ip[i] = pdata[8+i];
			}
			ip[iplen] = 0;
			newip = ip;
			Sender::m_sendtoIPs[newip] = nport;
			Sender::AddIPAndPortMask = true;
			//PRINTF("Receive AddIPAndPort Command");
		}
	}
}
bool Sender::ExitMask = false;
bool Sender::CaliMask = false;
bool Sender::SaveMask = false;
bool Sender::SetDisRateMask = false;
bool Sender::AddIPAndPortMask = false;
unsigned int Sender::SegmentMask[BODY_PART_COUNT] = {0,0,0};
double Sender::m_disrate;
map<QString, int> Sender::m_sendtoIPs;
Sender::Sender()
{
	m_iLeftAcc = 0;
	m_iRightAcc = 0;
	m_calihavedone = false;
	m_cansenddata = true;
	m_minmoveflag = MAXSHORT;
	m_premovelessseg = -1;
	m_movelessseg = -1;
	for(int i=0;i<BODY_PART_COUNT;i++)
		m_segmentflag[i]= 0;
	m_iNodeCount[0] = BODY_NODE_COUNT;
	m_iNodeCount[1] = FINGER_NODE_COUNT;
	m_iNodeCount[2] = FINGER_NODE_COUNT;
	m_sampleCounter = 0;
	m_inilmflag = 0;
	m_inirmflag = 0;
	for (int i=0; i<BODY_NODE_COUNT+1+FINGER_NODE_COUNT*2; i++)
	//for (int i=0; i<24; i++)
		m_segment[i].set(0.0, 0.0, 0.0, 1.0);
	//connect(&m_SenderThread, SIGNAL(notify()), this, SLOT(sendFrame()));
	//加载骨骼出事位置信息
};

Sender::~Sender()
{
	m_udpSocket.CloseSocket(); 
	//fclose(Gfp);
}
void Sender::inifootandhipspos()
{
	for (int i=0; i<BONENUM; i++)
	{
		m_bonepos[i].set(0.0, 0.0, 0.0);
		int nsegid = i;
		while (nsegid != -1)
		{
			m_bonepos[i] +=  osg::Vec3f(m_bones[nsegid].px, m_bones[nsegid].py, m_bones[nsegid].pz);//计算所有骨骼相对根节点的位置
			nsegid = m_parentbone[nsegid];
		}
	}
	m_inirightfpos = m_bonepos[18];
	m_inileftfpos = m_bonepos[22];
	m_inihipspos = m_bonepos[0];	
}
void Sender::iniParentrelationship()
{
    m_parentbone[0] = -1;
	m_parentbone[1] = 0;
	m_parentbone[2] = 1;
	m_parentbone[3] = 2;
	m_parentbone[4] = 3;
	m_parentbone[5] = 4;
	m_parentbone[6] = 5;

	m_parentbone[7] = 4;
	m_parentbone[8] = 7;
	m_parentbone[9] = 8;
	m_parentbone[10] = 9;

	m_parentbone[11] = 4;
	m_parentbone[12] = 11;
	m_parentbone[13] = 12;
	m_parentbone[14] = 13;

	m_parentbone[15] = 0;
	m_parentbone[16] = 15;
	m_parentbone[17] = 16;
	m_parentbone[18] = 17;

	m_parentbone[19] = 0;
	m_parentbone[20] = 19;
	m_parentbone[21] = 20;
	m_parentbone[22] = 21;

}

void Sender::loadskeleton()
{ 
#ifndef NDEBUG
	QFile file(QString("E:\\motion\\motioncapture\\Win32\\Release\\media\\models\\%1.xml").arg(m_ModelName));   
#else
	TCHAR exepath[260];
	qcommon::GetExePath(exepath);
    QFile file(QString("%1").arg(exepath) + QString("\\media\\models\\%1.xml").arg(m_ModelName));
// 	QString temp1 = QString("%1").arg(exepath) + QString("\\media\\models\\skeleton.xml");
// 	PRINTF(temp1.toAscii());
#endif
    
	if(!file.open(QIODevice::ReadWrite))  
		return;  
	QDomDocument doc;  
	doc.setContent(&file);  
	QDomElement root = doc.firstChildElement("skeleton").firstChildElement("bones");
	QDomElement elt = root.firstChildElement("bone");
	for (; !elt.isNull(); elt = elt.nextSiblingElement("bone")) 
	{
		int nsegid = elt.attribute("segid").toInt();
		if (nsegid >= 0 && nsegid < BONENUM)
		{
		    m_bones[nsegid].id = elt.attribute("id").toInt();
			m_bones[nsegid].name = elt.attribute("name");
// 			if ((nsegid == 20)||(nsegid == 16))//大腿
// 			{
// 				m_bones[nsegid].px = 0;
// 				m_bones[nsegid].py = -m_uplegLength * cos(m_uplegTiltAngle * 3.1415926 / 180);
// 				m_bones[nsegid].pz = m_uplegLength * sin(m_uplegTiltAngle * 3.1415926 / 180);
// 			}
// 			else if ((nsegid == 21)||(nsegid == 17))//小腿
// 			{
// 				m_bones[nsegid].px = 0;
// 				m_bones[nsegid].py = -m_legLength * cos(m_legTiltAngle * 3.1415926 / 180);
// 				m_bones[nsegid].pz = m_legLength * sin(m_legTiltAngle * 3.1415926 / 180);
// 			}
// 			else//其他
// 			{

				QDomElement poselt = elt.firstChildElement("position");
				m_bones[nsegid].px = poselt.attribute("x").toFloat();
				m_bones[nsegid].py = poselt.attribute("y").toFloat();
				m_bones[nsegid].pz = poselt.attribute("z").toFloat();
			//}

			QDomElement rotelt = elt.firstChildElement("rotation");
			m_bones[nsegid].angle = rotelt.attribute("angle").toFloat();

			QDomElement axiselt = elt.firstChildElement("axis");
			m_bones[nsegid].rx = axiselt.attribute("x").toFloat();
			m_bones[nsegid].ry = axiselt.attribute("y").toFloat();
			m_bones[nsegid].rz = axiselt.attribute("z").toFloat(); 


		}

	}
	file.close();  
}
void Sender::bind()
{
	if(!m_udpSocket.BindSocket(m_receiveport , RecvDatafunc))
	{
		m_cansenddata = false;
		MessageBoxA(NULL,"绑定端口错误", "错误", MB_YESNO|MB_ICONQUESTION|MB_SYSTEMMODAL);
	}
	//m_SenderThread.startRender();
}

void Sender::calcOtherSegmentQuat()
{
	m_segment[17] = m_segment[18];
	m_segment[21] = m_segment[22];
	//Calc neck quat
	m_segment[5] = quatutils::slerp(m_segment[4], m_segment[6]);
	//assert((m_segment[5].x() != 0)&&(m_segment[5].y() != 0)&&(m_segment[5].z() != 0)&&(m_segment[5].w() != 0));
	//Calc L5 L3 T12
	m_segment[1] = quatutils::slerp(m_segment[0], m_segment[4], 0.1);
	m_segment[2] = quatutils::slerp(m_segment[0], m_segment[4], 0.3);
	m_segment[3] = quatutils::slerp(m_segment[2], m_segment[4], 0.5);
	//assert((m_segment[1].x() != 0)&&(m_segment[1].y() != 0)&&(m_segment[1].z() != 0)&&(m_segment[1].w() != 0));
	//assert((m_segment[2].x() != 0)&&(m_segment[2].y() != 0)&&(m_segment[2].z() != 0)&&(m_segment[2].w() != 0));
	//assert((m_segment[3].x() != 0)&&(m_segment[3].y() != 0)&&(m_segment[3].z() != 0)&&(m_segment[3].w() != 0));
	
}

int Sender::genDatagram(char* pdata,osg::Quat* pQuat,osg::Vec3f* pVec,int iLen)//按MVN格式打包数据
{
	MNV::MVN_HEADER header;
	int nsize = 0;
	header.IdString[0] = 'M';
	header.IdString[1] = 'I';
	header.IdString[2] = 'T';
	header.IdString[3] = 'P';
	header.IdString[4] = '0';
	header.IdString[5] = '2';

	header.SampleCounter = m_sampleCounter++;
	header.DatagramCounter = 0x80;
	header.ItemsNumber = iLen;//23

	time_t now_time; 
	now_time = time(NULL);
	header.TimeCode = now_time;

	header.AvatarID = m_AvatarID;
	nsize += sizeof(MNV::MVN_HEADER);
    memcpy((void*)pdata, (void*)(&header), nsize);
	pdata += sizeof(MNV::MVN_HEADER);

	for (int i=0; i<iLen; i++) 
	{
		MNV::PoseData02 posedata;
		posedata.segmentId = ntohl(UINT32(i+1));
		//if (i == 0)
		//{
		posedata.position.x = Myntohl(pVec[i].z()/m_disrate);
		posedata.position.y = Myntohl(pVec[i].x()/m_disrate);
		posedata.position.z = Myntohl(pVec[i].y()/m_disrate);
		//}
		//else
		//{
		//	posedata.position.x = ntohl(UINT32(0));
		//	posedata.position.y = ntohl(UINT32(0));
		//	posedata.position.z = ntohl(UINT32(0));
		//}
// 		posedata.quaternion.q1 = Myntohl(-m_segment[i].w());
// 		posedata.quaternion.q2 = Myntohl(m_segment[i].x());
// 		posedata.quaternion.q3 = Myntohl(m_segment[i].y());
// 		posedata.quaternion.q4 = Myntohl(-m_segment[i].z());
		posedata.quaternion.q1 = Myntohl(-pQuat[i].w());
		posedata.quaternion.q2 = Myntohl(-pQuat[i].z());
		posedata.quaternion.q3 = Myntohl(-pQuat[i].x());
		posedata.quaternion.q4 = Myntohl(-pQuat[i].y());
		memcpy((void*)pdata, (void*)(&posedata), sizeof(MNV::PoseData02));
		pdata += sizeof(MNV::PoseData02);
		nsize += sizeof(MNV::PoseData02);
	}

    return nsize;
}

void Sender::setWeightNess(bool weightnessless)
{
    m_weightnessless = weightnessless;
}

void Sender::hipsPosChange(double posx, double posy, double posz)
{
	//75 todo
	double tempx, tempy;
	tempx = posx;
	tempy = posy;
	//posx = tempx*cos(m_rhangle) - tempy*sin(m_rhangle);
	//posy = tempx*sin(m_rhangle) + tempy*cos(m_rhangle);
	//posy = tempy*cos(m_rhangle) - tempx*sin(m_rhangle);
	//posx = tempy*sin(m_rhangle) + tempx*cos(m_rhangle);
    m_hipPosIncx = posx*500;
	m_hipPosIncy = posz*500;
	m_hipPosIncz = posy*500;
}
void Sender::sendToMaya()
{
	float databuffer[4*24];
	for (int i=0; i< 23; i++)
	{
		databuffer[i*4] = m_segment[i].x();
		databuffer[i*4 + 1] = m_segment[i].y();
		databuffer[i*4 + 2] = -m_segment[i].z();
		databuffer[i*4 + 3] = -m_segment[i].w();
	}
	databuffer[23*4] = m_segment[23].x();
	databuffer[23*4 + 1] = m_segment[23].y();
	databuffer[23*4 + 2] = m_segment[23].z();
	sendToAll((char*)databuffer, sizeof(float)*4*24);

}

bool Sender::sendToAll(char* buffer, int len)
{
	map<QString, int>::iterator   it=m_sendtoIPs.begin();   
	for(;it!=m_sendtoIPs.end();++it)   
	{
		m_udpSocket.SendData(it->first.toAscii(), it->second, buffer, len);
	}
	return true;
}
void Sender::sendFrame(bool cali)
{
	float senddata[4*60];
	osg::Vec3f vec[60];
	osg::Quat quat[60];
	int iMVNIndex=0;
	if (!m_calihavedone)
		m_calihavedone = cali;
	//1684224,1701632 (1701633 + (1<<4) + (1<<22) + (1<<18) + (1<<7) + (1<<11) + (1<<6))
	int iBodyPartCount=0,iCompleteCount=0;
	for(int k=0;k<BODY_PART_COUNT;k++)
	{
// 		if (m_segmentflag[k] == SegmentMask[k] && SegmentMask[k] !=0)
// 		{
// 			if(k==0)
// 			{
// 				PRINTF("Sender::sendFrame::Begin calcPosition");
// 				calcOtherSegmentQuat();
// 				//计算位移
// 				calcPosition(cali);
// 				PRINTF("Sender::sendFrame::end calcPosition");
// 
// 			}
// 			if (m_calihavedone)
// 			{
// 				int sizeofdata = genDatagram(m_datagrambuffer,k);//按MVN格式打包数据
// 				sendToAll(m_datagrambuffer, sizeofdata);
// 			}
// 			int iBegin=0;
// 			for(int m=0;m<k;m++)
// 				iBegin+=(m_iNodeCount[m]+(m==0));
// 			for (int i=0; i< m_iNodeCount[k]+(k==0); i++)
// 			{
// 				senddata[i*4] = m_segment[i+iBegin].x();
// 				senddata[i*4 + 1] = m_segment[i+iBegin].y();
// 				senddata[i*4 + 2] = m_segment[i+iBegin].z();
// 				senddata[i*4 + 3] = m_segment[i+iBegin].w();
// 			}
// 			//发送到maya场景
// 			//sendToMaya();
// 
// 
// 			m_segmentflag[k] = 0;
// 	 		
// 			//if (m_calihavedone)
// 			   FOgreWidget::DriveBone((char*)(senddata), sizeof(float)*4*(m_iNodeCount[k]+(k==0)), cali, m_movelessseg,k);
// 			m_minmoveflag = MAXSHORT;
// 			m_movelessseg = -1;
// 
// 			//fwrite(senddata+8*4, sizeof(float), 12, Gfp);
// 			
// 		}
		if( SegmentMask[k] ==0) continue;//没有接入该设备
		iBodyPartCount++;
		if(m_segmentflag[k] == SegmentMask[k])
		{
			iCompleteCount++;
		}
	}
	if(iCompleteCount == iBodyPartCount && iCompleteCount>0)
	{
		//bool bBodyPart=false;
		int iDataLen=0;
		for(int k=0;k<BODY_PART_COUNT;k++)
		{
			if( SegmentMask[k] ==0) continue;//没有接入该设备
			if(m_segmentflag[k] == SegmentMask[k])
			{
				if(k==0)
				{
					//PRINTF("Sender::sendFrame::Begin calcPosition");
					calcOtherSegmentQuat();
					//计算位移
					calcPosition(cali);
					//PRINTF("Sender::sendFrame::end calcPosition");
				}
				int iBegin=0;
				for(int m=0;m<k;m++)
					iBegin+=(m_iNodeCount[m]+(m==0));
				int iIndex=0;
				for (int i=0; i< m_iNodeCount[k]+(k==0); i++)
				{
					if(k==0 && i==m_iNodeCount[k] || (k>0 && i>=15))//位移 \ 第六指 mvn不要
					{
						;//bBodyPart = true;
						if(k==0 && i==m_iNodeCount[k])
						{
							senddata[iIndex*4] = m_segment[i+iBegin].x();
							senddata[iIndex*4 + 1] = m_segment[i+iBegin].y();
							senddata[iIndex*4 + 2] = m_segment[i+iBegin].z();
							senddata[iIndex*4 + 3] = m_segment[i+iBegin].w();
							iIndex++;
						}
					}
					else
					{
						senddata[iIndex*4] = m_segment[i+iBegin].x();
						senddata[iIndex*4 + 1] = m_segment[i+iBegin].y();
						senddata[iIndex*4 + 2] = m_segment[i+iBegin].z();
						senddata[iIndex*4 + 3] = m_segment[i+iBegin].w();
						iIndex++;

						quat[iMVNIndex] = m_segment[i+iBegin];
						vec[iMVNIndex] = m_bonepos[i+iBegin];
						iMVNIndex++;
					}
				}
				
				memcpy(m_datagrambuffer+iDataLen,senddata,sizeof(float)*4*iIndex);
				iDataLen+=sizeof(float)*4*iIndex;
				if (m_model)
					m_model->DriveBone((char*)(senddata), sizeof(float)*4*iIndex, cali, m_movelessseg,k);

				m_segmentflag[k] = 0;
				
			}
		}
		if(m_calihavedone)
		{
			int sizeofdata = iDataLen;
			if(m_iSendDataFormat==1)
			{
				sizeofdata = genDatagram(m_datagrambuffer,quat,vec,iMVNIndex);//按MVN格式打包数据
			}
			sendToAll(m_datagrambuffer, sizeofdata);
		}

		m_minmoveflag = MAXSHORT;
		m_movelessseg = -1;
		m_iLeftAcc = 0;
		m_iRightAcc = 0;
	}

}

bool Sender::sendState(int state)
{
	unsigned int ntemp = state;
	char data[10];
	data[0] = 0xB4;
	data[1] = 0x4B;
	data[2] = 7;
	data[3] = 0x06;
	data[4] = ntemp & 255;
	ntemp>>=8;
	data[5] = ntemp & 255;
	ntemp>>=8;
	data[6] = ntemp & 255;
	ntemp>>=8;
	data[7] = ntemp & 255;

	data[8] = 0xAA;
	return (m_udpSocket.SendData("127.0.0.1", m_severport, (char*)(data), 9) != -1);
}

void Sender::load(Configuration* config)
{
	ceckPiracy(config);
    m_tarport = config->get(CQMAIN, CQTARPORT).toUInt();
	m_tarport1 = config->get(CQMAIN, CQTARPORT1).toUInt();
	m_severport = config->get(CQMAIN, CQSEVERPORT).toUInt();
	m_receiveport = config->get(CQMAIN, CQRECEIVEPORT).toUInt();
	m_disrate = config->get(CQMAIN, CQDISRATE, "1").toInt();
	m_ModelName = config->get(CQMAIN, CQMODELNAME);
	m_AvatarID = config->get(CQMAIN, CQACTORID).toUInt();
	m_uplegLength = config->get(CQMAIN, CQULLENGTH).toFloat();
	m_legLength = config->get(CQMAIN, CQLLENGTH).toFloat();
	m_uplegTiltAngle = config->get(CQMAIN, CQULTANGLE).toFloat();
	m_legTiltAngle = config->get(CQMAIN, CQLLENGTH).toFloat();
	m_jumpable = (config->get(CQMAIN, CQJUMPABLE).toUInt() == 1);
	int nIPcount = config->get(CQMAIN, CQSENDIPCOUNT).toUInt();
	for (int i=0; i< nIPcount; i++)
	{
		m_sendtoIPs[config->get(CQMAIN, QString("IP%1").arg(i))] = config->get(CQMAIN, QString("Port%1").arg(i)).toInt();
	}

	loadskeleton();
	iniParentrelationship();
	inifootandhipspos();
}

bool Sender::sendQuat(int portID, int segmentlabel, const osg::Quat& quat, bool cali, short moveflag, bool weightnessless)//准备驱动模型数据wxg6  moveflag为：加速度向量(扣除重力加速度后的)的模*1000
{
	//PRINTF("Sender::sendQuat::Begin sendQuat: %f, %f, %f, %f", quat.x(), quat.y(), quat.z(), quat.w());
	if (cali)//校准时 初始化两个脚掌的位置
	{
	   if (segmentlabel == 18)
		   m_inirmflag = moveflag;
	   else if (segmentlabel == 22)
		   m_inilmflag = moveflag;

	   //wxg
	   if(segmentlabel>=0 && segmentlabel < 24)
			m_quatCali[segmentlabel].set(quat.x(), quat.y(), quat.z(), quat.w());
	}
	if (segmentlabel == 18)
	{
		moveflag -= m_inirmflag;
		m_iRightAcc = moveflag;
		if (moveflag < m_minmoveflag)//找出加速度最小（静止）的脚  m_minmoveflag值在所有模块采集一遍后复位
		{
			m_minmoveflag = moveflag;
		    m_movelessseg = segmentlabel;
		}
		PRINTF("leftacc=%d,rightacc=%d",m_iLeftAcc,m_iRightAcc);
	}
	else if (segmentlabel == 22)
	{
	    moveflag -= m_inilmflag;
		m_iLeftAcc = moveflag;
		if (moveflag < m_minmoveflag)
		{
			m_minmoveflag = moveflag;
			m_movelessseg = segmentlabel;
		}
		PRINTF("leftacc=%d,rightacc=%d",m_iLeftAcc,m_iRightAcc);
	}
// 	if ((moveflag < m_minmoveflag) &&(segmentlabel == 18 || segmentlabel == 22))
// 	{
// 		m_minmoveflag = moveflag;
// 		m_movelessseg = segmentlabel;
// 	}
	if (!m_cansenddata) return false;
	if (segmentlabel >= 0 && segmentlabel < 24)
	{
        //while (m_segmentflag & (1<<segmentlabel))
			sendFrame(cali);
			assert(!((quat.x() == 0)&&(quat.y() == 0)&&(quat.z() == 0)&&(quat.w() == 0)));
			//m_segment[segmentlabel].set(quat.x(), quat.y(), -quat.z(), -quat.w());//改变轴向???wxg1
			m_segment[segmentlabel].set(quat.x(), quat.y(), quat.z(), quat.w());
        //m_segment[segmentlabel] = quat;
		//m_lock.lock();
		m_segmentflag[0] |= (1<<segmentlabel);
		//m_lock.unLock();
	}
	else if(segmentlabel >= 24 && segmentlabel < 42 )
	{
		sendFrame(cali);
		assert(!((quat.x() == 0)&&(quat.y() == 0)&&(quat.z() == 0)&&(quat.w() == 0)));

		m_segment[segmentlabel].set(quat.x(), quat.y(), quat.z(), quat.w());
		segmentlabel-=24;
		m_segmentflag[1] |= (1<<segmentlabel);		
	}
	else if(segmentlabel >= 42 && segmentlabel < 60 )
	{
		sendFrame(cali);
		assert(!((quat.x() == 0)&&(quat.y() == 0)&&(quat.z() == 0)&&(quat.w() == 0)));

		m_segment[segmentlabel].set(quat.x(), quat.y(), quat.z(), quat.w());
		segmentlabel-=42;
		m_segmentflag[2] |= (1<<segmentlabel);		
	}

	else
	{
		sendToAll((char*)(quat._v), sizeof(double)*4);
	}

	//PRINTF("Sender::sendQuat::End sendQuat");
	return true;
}
// bool Sender::sendQuat(int portID, int segmentlabel, const osg::Quat& quat, bool cali, short moveflag, bool weightnessless)
// {
// 	//PRINTF("Sender::sendQuat::Begin sendQuat: %f, %f, %f, %f", quat.x(), quat.y(), quat.z(), quat.w());
// 	static int lcount,rcount = 0;
// 	if (cali)
// 	{
// 		if (segmentlabel == 18)
// 			m_inirmflag = moveflag;
// 		else if (segmentlabel == 22)
// 			m_inilmflag = moveflag;
// 	}
// 	if (segmentlabel == 18)
// 	{
// 		moveflag -= m_inirmflag;
// 		if (moveflag > 100)	// edit by mvp ## 2015-6-26
// 		{
// 			m_right_moveflag = true;		 
// 			rcount = 0;
// 		}
// 		else
// 		{
// 			if(rcount++ > 20)	// leave out the 
// 				m_right_moveflag = false;			
// 		}
// 		m_movelessseg = segmentlabel;
// 		m_minmoveflag = moveflag;
// 	}
// 	else if (segmentlabel == 22)
// 	{
// 		moveflag -= m_inilmflag;
// 		if (moveflag > 100)	// edit by mvp ## 2015-6-26
// 		{
// 			m_left_moveflag = true;		 
// 			lcount = 0;
// 		}
// 		else
// 		{
// 			if(lcount++ > 20)	// leave out the 
// 				m_left_moveflag = false;			
// 		}
// 		m_movelessseg = segmentlabel;
// 		m_minmoveflag = moveflag;
// 	}
// 	// 	if ((moveflag < m_minmoveflag) &&(segmentlabel == 18 || segmentlabel == 22))
// 	// 	{
// 	// 		m_minmoveflag = moveflag;
// 	// 		m_movelessseg = segmentlabel;
// 	// 	}
// 	if (!m_cansenddata) return false;
// 	if (segmentlabel != -1)
// 	{
// 		//while (m_segmentflag & (1<<segmentlabel))
// //		sendFrame(cali);
// 		//assert(!((quat.x() == 0)&&(quat.y() == 0)&&(quat.z() == 0)&&(quat.w() == 0)));
// 		m_segment[segmentlabel].set(quat.x(), quat.y(), quat.z(), quat.w());
// 		//m_segment[segmentlabel] = quat;
// 		//m_lock.lock();
// 		m_segmentflag[0] |= (1<<segmentlabel);
// 		//m_lock.unLock();
// 	}
// 	else
// 	{
// 		sendToAll((char*)(quat._v), sizeof(double)*4);
// 	}
// 
// 	//PRINTF("Sender::sendQuat::End sendQuat");
// 	return true;
// }

bool Sender::sendData(UINT portnum, char* buffer, int len)
{
	if (!m_cansenddata) return false;
	map<QString, int>::iterator   it=m_sendtoIPs.begin();   
	for(;it!=m_sendtoIPs.end();++it)   
	{
		m_udpSocket.SendData(it->first.toAscii(), portnum, buffer, len);
	}
	return true;
}

bool Sender::sendData(int portID, float yaw, float pitch, float roll, bool zero)
{
	if (!m_cansenddata) return false;
	byte *data;
	byte nlen = sizeof(float) * 3 + 1;
	data = new byte[nlen];

	memcpy(data, (void*)(&yaw), sizeof(float));
	memcpy(data+sizeof(float), (void*)(&pitch), sizeof(float));
	memcpy(data+sizeof(float)*2, (void*)(&roll), sizeof(float));

	if (zero)
		data[sizeof(float)*3] = 1;
	else
	    data[sizeof(float)*3] = 0;

	sendToAll((char*)data, nlen);
	delete[] data;
	return true;
}

void Sender::swapTarPort()
{
	UINT temp = m_tarport;
	m_tarport = m_tarport1;
	m_tarport1 = temp;
}

bool Sender::jumpable()
{
	//return false;
    if (!m_jumpable) return false;
 	if (!m_weightnessless)
    {
        if ((m_bonepos[22].y() > m_inileftfpos.y() + 5) && (m_bonepos[18].y() > m_inileftfpos.y() + 5)&&(m_minmoveflag>50))//两脚高度离开地面5个单位以上，加
		{	
			PRINTF("___jumpable left=%f,initleft=%f,right=%f,initright=%f,m_minmoveflag=%d",(float)m_bonepos[22].y(), (float)m_inileftfpos.y() ,(float)m_bonepos[18].y() , (float)m_inileftfpos.y(),m_minmoveflag);
 		   return true;
		}
 	}
	return m_weightnessless;
// 	if (m_hipPosIncy > 0.23)
// 	{
//         if ((m_bonepos[17].y()>13)&&(m_bonepos[21].y()>13))
// 		    return true;
// 		else return false;
// 	}
// 	else  if (m_jumpposqueue.size() > 0)
// 	{
//         //if ((m_bonepos[18].y() > (m_inileftfpos.y() + 0.0001))&&(m_bonepos[22].y() > (m_inileftfpos.y() + 0.0001)))
// 			return true;
// 	}
// 	else
// 		return false;

}

double maxgtesty = 0;
void Sender::calcPosition(bool cali)
{
	static bool rfootonfloor = false, lfootonfloor=false;
	static double velocity = 0; 
	static osg::Vec3f rightfootpos, leftfootpos, hipspos;

	static double yaw0Hop=0.0,yaw0Leftfoot=0.0,yaw0Rightfoot=0.0,offsetLAngle=0.0,offsetRAngle=0.0;//wxg20150708滑步
	osg::Quat m_pquat;
	double pi = 3.14159;

	if (cali)
	{
		rightfootpos.set(m_inirightfpos.x(), m_inirightfpos.y(), m_inirightfpos.z());
		leftfootpos.set(m_inileftfpos.x(), m_inileftfpos.y(), m_inileftfpos.z());
		hipspos.set(m_inihipspos.x(), m_inihipspos.y(), m_inihipspos.z());

		//wxg20150708滑步
		offsetLAngle=0.0;
		offsetRAngle=0.0;
		m_pquat = m_quatCali[0];
		yaw0Hop = atan2(2 * m_pquat.x() * m_pquat.y() + 2 * m_pquat.w() * m_pquat.z(), -2 * m_pquat.y()*m_pquat.y() - 2 * m_pquat.z() * m_pquat.z() + 1)* 180/pi; // yaw
		m_pquat = m_quatCali[22];
		yaw0Leftfoot = atan2(2 * m_pquat.x() * m_pquat.y() + 2 * m_pquat.w() * m_pquat.z(), -2 * m_pquat.y()*m_pquat.y() - 2 * m_pquat.z() * m_pquat.z() + 1)* 180/pi; // yaw
		m_pquat = m_quatCali[18];
		yaw0Rightfoot = atan2(2 * m_pquat.x() * m_pquat.y() + 2 * m_pquat.w() * m_pquat.z(), -2 * m_pquat.y()*m_pquat.y() - 2 * m_pquat.z() * m_pquat.z() + 1)* 180/pi; // yaw
		PRINTF("--------------quat0:  yaw0Hop=%f,yaw0Leftfoot=%f,yaw0Rightfoot=%f",yaw0Hop,yaw0Leftfoot,yaw0Rightfoot);
		return;
	}
	if (!m_calihavedone)
		return;

	osg::Vec3f rpos(0.0, 0.0, 0.0);//右脚掌相对根节点的位移
	int nseg = 18;//从右脚掌最末端开始 累计所有父节点的位移 
	while (nseg != 0)
	{
		rpos += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);
		nseg = m_parentbone[nseg];
	}

	osg::Vec3f lpos(0.0, 0.0, 0.0);
	nseg = 22;//左脚掌
	while (nseg != 0)
	{
		lpos += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);
		nseg = m_parentbone[nseg];

	}

	osg::Vec3f hpos(0.0, 0.0, 0.0);
	float er = 0.001;
// 	if (m_weightnessless)
// 	    PRINTF(QString("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddd    weight of z:%1, weightnessless = true").arg(m_hipPosIncy/500.0).toStdString());
// 	else
// 		PRINTF(QString("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddd    weight of z:%1, weightnessless = false").arg(m_hipPosIncy/500.0).toStdString());
	if (jumpable())//有跳跃
	{
		
		hpos = m_bonepos[0];
		hpos._v[0] += m_hipPosIncx;//原位置+移动值=根节点新位置
		hpos._v[1] += m_hipPosIncy;
		hpos._v[2] += m_hipPosIncz;
		for (int i=0; i<BONENUM; i++)
		{
			m_bonepos[i].set(hpos.x(), hpos.y(), hpos.z());
			nseg = i;
			while (nseg != 0)
			{
				m_bonepos[i] += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);//更新位移信息
				nseg = m_parentbone[nseg];
			}
		}
		leftfootpos  = m_bonepos[22];
		rightfootpos = m_bonepos[18];
	}
	else//静止或行走
	{
		//m_jumpposqueue.clear();
		if (m_movelessseg == 22)//左脚的加速度小 
		{
			double ddis;
			if (rfootonfloor)//右脚曾静止
			{
				velocity = 0.0;
				rfootonfloor = false;
				lfootonfloor = true;
			}
			else//右脚原先在动
			{
				ddis = velocity / 120 + 9.8 /120/120/2;//t=(1/120)秒 上一时刻到这一时刻的位移s=V0*t+0.5*g*t^2 
				velocity += 9.8/120;//新的初始速度
				if ((leftfootpos[1] - m_inileftfpos.y()) <ddis)//
					ddis = leftfootpos[1] - m_inileftfpos.y(); 

	// 			if ((rightfootpos[1] - m_inileftfpos.y()) < ddis)
	// 				ddis = rightfootpos[1] - m_inileftfpos.y();
				leftfootpos[1] -= ddis;//拉回地面
				lfootonfloor = true;
			}

			hpos = leftfootpos - lpos;//根节点的位置
			rightfootpos = hpos + rpos;//
		}
		else if (m_movelessseg == 18)//右脚不动
		{
			double ddis;
			if (lfootonfloor)
			{
				velocity = 0.0;
				lfootonfloor = false;
				rfootonfloor = true;
			}
			else
			{
				ddis = velocity / 120 + 9.8 /120/120/2;
				velocity += 9.8/120;
				if ((rightfootpos[1] - m_inileftfpos.y()) <ddis)
					ddis = rightfootpos[1] - m_inileftfpos.y();

	// 			if ((leftfootpos[1] - m_inileftfpos.y()) < ddis)
	// 				ddis = leftfootpos[1] - m_inileftfpos.y();
				rightfootpos[1] -= ddis;
				rfootonfloor = true;
			}
			hpos = rightfootpos - rpos;
			leftfootpos = hpos + lpos;

		}
		else{//
			hpos = hipspos;
			PRINTF("--------------------moveless.");
		}

		if (m_hipPosIncy > maxgtesty)
			maxgtesty = m_hipPosIncy;//根节点最大上升高度 没有用到
		if (m_jumpable)
		{
			hpos._v[1] = m_bonepos[0]._v[1] + m_hipPosIncy;
		}
	 	if (m_bonepos[18].y() < m_bonepos[22].y())//wxg 20150630
	 	{
	 		hpos._v[1] -= m_bonepos[18].y() - m_inileftfpos.y();//以脚（地面）为参考，拉回地面
      	}
	 	else
		{
	 		hpos._v[1] -= m_bonepos[22].y() - m_inileftfpos.y();
	 	}

		//wxg20150708滑步
		m_pquat = m_segment[0];
		double yawHop = atan2(2 * m_pquat.x() * m_pquat.y() + 2 * m_pquat.w() * m_pquat.z(), -2 * m_pquat.y()*m_pquat.y() - 2 * m_pquat.z() * m_pquat.z() + 1)* 180/pi; // yaw
		m_pquat.set(m_segment[0].x(),m_segment[0].y(),m_segment[0].z(),-m_segment[0].w());
		double _yawHop = atan2(2 * m_pquat.x() * m_pquat.y() + 2 * m_pquat.w() * m_pquat.z(), -2 * m_pquat.y()*m_pquat.y() - 2 * m_pquat.z() * m_pquat.z() + 1)* 180/pi; // yaw
		m_pquat = m_segment[22];
		double yawLeftfoot = atan2(2 * m_pquat.x() * m_pquat.y() + 2 * m_pquat.w() * m_pquat.z(), -2 * m_pquat.y()*m_pquat.y() - 2 * m_pquat.z() * m_pquat.z() + 1)* 180/pi; // yaw
		m_pquat = m_segment[18];
		double yawRightfoot = atan2(2 * m_pquat.x() * m_pquat.y() + 2 * m_pquat.w() * m_pquat.z(), -2 * m_pquat.y()*m_pquat.y() - 2 * m_pquat.z() * m_pquat.z() + 1)* 180/pi; // yaw
		PRINTF("-----------------------yawHop=%f,-yawHop=%f,yawLeft=%f,yawRight=%f...yH-yH0=%f,yL-yL0=%f,yR-yR0=%f",yawHop,_yawHop,yawLeftfoot,yawRightfoot,yawHop-yaw0Hop,yawLeftfoot-yaw0Leftfoot,yawRightfoot-yaw0Rightfoot);
 		osg::Quat quat0,quat1;
// 		quat0.set(0,0,0,1);

		for (int i=0; i<BONENUM; i++)
		{
			m_bonepos[i].set(hpos.x(), hpos.y(), hpos.z());//更新根节点位置
			nseg = i;
// 			while (nseg != 0)
// 			{
// 				m_bonepos[i] += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);//更新位移信息
// 				nseg = m_parentbone[nseg];
// 			}
			while (nseg != 0)//wxg20150708滑步
			{
				m_bonepos[i] += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);//更新位移信息
				nseg = m_parentbone[nseg];
			}
			double fOffset=0.0;
			if(i==22)
			{
				fOffset = yawHop-yawLeftfoot-(yaw0Hop-yaw0Leftfoot)-offsetLAngle;
				offsetLAngle += fOffset;
			}
			else if(i==18)
			{
				fOffset = yawHop-yawRightfoot-(yaw0Hop-yaw0Rightfoot)-offsetRAngle;
				offsetRAngle += fOffset;
			}
// 			if(abs(fOffset) > 5)
// 			{
// //				quat1 = -m_segment[0];
// // 				quat1 = quatutils::slerp(quat0,quat1);
// 				quat1 = quatutils::EulorToQuat(0, 0, fOffset, 1);
// 				//quat1.set(quat1.x(),quat1.y(),quat1.z(),-quat1.w());
// 				//m_bonepos[i] = quat1 * m_bonepos[i];//更新位移信息 m_bonepos这个是发给别人的，自己的场景用的是m_segment  这个也有影响
// 				m_pquat =  m_segment[i-3];
// 				double yaw = atan2(2 * m_pquat.x() * m_pquat.y() + 2 * m_pquat.w() * m_pquat.z(), -2 * m_pquat.y()*m_pquat.y() - 2 * m_pquat.z() * m_pquat.z() + 1)* 180/pi; // yaw
// 				double pitch = -asin(-2 * m_pquat.x() * m_pquat.z() + 2 * m_pquat.w() * m_pquat.y())* 180/pi; // pitch
// 				double roll = atan2(2 * m_pquat.y() * m_pquat.z() + 2 * m_pquat.w() * m_pquat.x(), -2 * m_pquat.x() * m_pquat.x() - 2 * m_pquat.y() * m_pquat.y() + 1)* 180/pi; // roll
// 				PRINTF("―――――fOffset=%f――――――m_segment[%d] yaw=%f,pitch=%f,roll=%f",fOffset,i-3,yaw,pitch,roll);
// 				m_segment[i-3] = quat1 * m_segment[i-3];//hop的子关节
// 				m_pquat = quat1;
// 				yaw = atan2(2 * m_pquat.x() * m_pquat.y() + 2 * m_pquat.w() * m_pquat.z(), -2 * m_pquat.y()*m_pquat.y() - 2 * m_pquat.z() * m_pquat.z() + 1)* 180/pi; // yaw
// 				pitch = -asin(-2 * m_pquat.x() * m_pquat.z() + 2 * m_pquat.w() * m_pquat.y())* 180/pi; // pitch
// 				roll = atan2(2 * m_pquat.y() * m_pquat.z() + 2 * m_pquat.w() * m_pquat.x(), -2 * m_pquat.x() * m_pquat.x() - 2 * m_pquat.y() * m_pquat.y() + 1)* 180/pi; // roll
// 				PRINTF("―――――――――――offset quat yaw=%f,pitch=%f,roll=%f",yaw,pitch,roll);
// 
// 				m_pquat = m_segment[i-3];
// 				yaw = atan2(2 * m_pquat.x() * m_pquat.y() + 2 * m_pquat.w() * m_pquat.z(), -2 * m_pquat.y()*m_pquat.y() - 2 * m_pquat.z() * m_pquat.z() + 1)* 180/pi; // yaw
// 				pitch = -asin(-2 * m_pquat.x() * m_pquat.z() + 2 * m_pquat.w() * m_pquat.y())* 180/pi; // pitch
// 				roll = atan2(2 * m_pquat.y() * m_pquat.z() + 2 * m_pquat.w() * m_pquat.x(), -2 * m_pquat.x() * m_pquat.x() - 2 * m_pquat.y() * m_pquat.y() + 1)* 180/pi; // roll
// 				PRINTF("―――――――――――m_segment[] yaw=%f,pitch=%f,roll=%f",yaw,pitch,roll);
// 				
// 			}
		}
	}
	m_segment[23].set(hpos.x() - hipspos.x(), hpos.y() - hipspos.y(), hpos.z() - hipspos.z(), 0);//根节点偏移 maya才用，已注去
	//m_segment[23].set(hpos.x(), hpos.y(), hpos.z(), 0);
	//hipspos = hpos;
}

// void Sender::calcPosition(bool cali)//modify by mvp
// {
// 	static bool rfootonfloor = false, lfootonfloor=false;
// 	static double velocity = 0; 
// 	static osg::Vec3f rightfootpos, leftfootpos, hipspos;
// 
// 	if (cali)
// 	{
// 		rightfootpos.set(m_inirightfpos.x(), m_inirightfpos.y(), m_inirightfpos.z());
// 		leftfootpos.set(m_inileftfpos.x(), m_inileftfpos.y(), m_inileftfpos.z());
// 		hipspos.set(m_inihipspos.x(), m_inihipspos.y(), m_inihipspos.z());
// 		return;
// 	}
// 	if (!m_calihavedone)
// 		return;
// 
// 	osg::Vec3f rpos(0.0, 0.0, 0.0);//右脚掌相对根节点的位移
// 	int nseg = 18;//从右脚掌最末端开始 累计所有父节点的位移 
// 	while (nseg != 0)
// 	{
// 		rpos += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);
// 		nseg = m_parentbone[nseg];
// 	}
// 
// 	osg::Vec3f lpos(0.0, 0.0, 0.0);
// 	nseg = 22;//左脚掌
// 	while (nseg != 0)
// 	{
// 		lpos += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);
// 		nseg = m_parentbone[nseg];
// 
// 	}
// 
// 	osg::Vec3f hpos(0.0, 0.0, 0.0);
// 	float er = 0.001;
// 	// 	if (m_weightnessless)
// 	// 	    PRINTF(QString("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddd    weight of z:%1, weightnessless = true").arg(m_hipPosIncy/500.0).toStdString());
// 	// 	else
// 	// 		PRINTF(QString("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddd    weight of z:%1, weightnessless = false").arg(m_hipPosIncy/500.0).toStdString());
// 	if (jumpable())//有跳跃
// 	{
// 
// 		hpos = m_bonepos[0];
// 		hpos._v[0] += m_hipPosIncx;//原位置+移动值=根节点新位置
// 		hpos._v[1] += m_hipPosIncy;
// 		hpos._v[2] += m_hipPosIncz;
// 		// init the Inc data //add by mvp ## 2015-7-8
// 		m_hipPosIncx = 0;
// 		m_hipPosIncy = 0;
// 		m_hipPosIncz = 0;
// 		for (int i=0; i<BONENUM; i++)
// 		{
// 			m_bonepos[i].set(hpos.x(), hpos.y(), hpos.z());
// 			nseg = i;
// 			while (nseg != 0)
// 			{
// 				m_bonepos[i] += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);//更新位移信息
// 				nseg = m_parentbone[nseg];
// 			}
// 		}
// 		leftfootpos  = m_bonepos[22];
// 		rightfootpos = m_bonepos[18];
// 	}
// 	else//静止或行走
// 	{
// 		//m_jumpposqueue.clear();
// 		if (m_movelessseg == 22)//左脚的加速度小 
// 		{
// 			double ddis;
// 			if (rfootonfloor)//first init
// 			{
// 				velocity = 0.0;//init
// 				rfootonfloor = false;
// 				lfootonfloor = true;
// 			}
// 			else//
// 			{
// 				ddis = velocity / 120 + 9.8 /120/120/2;//t=(1/120)秒 上一时刻到这一时刻的位移s=V0*t+0.5*g*t^2 
// 				velocity += 9.8/120;//新的初始速度
// 				if ((leftfootpos[1] - m_inileftfpos.y()) <ddis)//解决跺脚问题？
// 					ddis = leftfootpos[1] - m_inileftfpos.y(); 
// 
// 				// 			if ((rightfootpos[1] - m_inileftfpos.y()) < ddis)
// 				// 				ddis = rightfootpos[1] - m_inileftfpos.y();
// 				leftfootpos[1] -= ddis;//
// 				lfootonfloor = true;
// 			}
// 
// // 			hpos = leftfootpos - lpos;//根节点的位置 //采用相对旋转来计算腰的位置// edit by mvp ## 2015-7-8
// // 			rightfootpos = hpos + rpos;
// 			hpos._v[1] = leftfootpos[1] - lpos._v[1];// change the  hpos to hpos_v[1] //add by mvp ## 2015-7-8 //采用16片上传的位移信息来计算腰的位置
// 			rightfootpos[1] = hpos._v[1] + rpos._v[1];//
// 		}
// 		else if (m_movelessseg == 18)//右脚不动
// 		{
// 			double ddis;
// 			if (lfootonfloor)
// 			{
// 				velocity = 0.0;
// 				lfootonfloor = false;
// 				rfootonfloor = true;
// 			}
// 			else
// 			{
// 				ddis = velocity / 120 + 9.8 /120/120/2;
// 				velocity += 9.8/120;
// 				if ((rightfootpos[1] - m_inileftfpos.y()) <ddis)
// 					ddis = rightfootpos[1] - m_inileftfpos.y();
// 
// 				// 			if ((leftfootpos[1] - m_inileftfpos.y()) < ddis)
// 				// 				ddis = leftfootpos[1] - m_inileftfpos.y();
// 				rightfootpos[1] -= ddis;
// 				rfootonfloor = true;
// 			}
// // 			hpos = rightfootpos - rpos;//edit by mvp ## 2015-7-8
// // 			leftfootpos = hpos + lpos;
// 			hpos._v[1] = rightfootpos[1] - rpos._v[1];	
// 			leftfootpos[1] = hpos._v[1] + lpos._v[1];
// 		}
// 		else{//
// 			hpos = hipspos;
// 		}
// 
// 		if (m_hipPosIncy > maxgtesty)
// 			maxgtesty = m_hipPosIncy;//根节点最大上升高度 没有用到
// 		if (m_jumpable)
// 		{
// 			hpos._v[1] = m_bonepos[0]._v[1] + m_hipPosIncy;
// 
// 			hpos._v[0] = m_bonepos[0]._v[0] + m_hipPosIncx;	// add by mvp ## 2015-7-8 采用16片上传的位移信息来计算腰的位置
// 			hpos._v[2] = m_bonepos[0]._v[2] + m_hipPosIncz;
// 			// init the Inc data //add by mvp ## 2015-7-8
// 			m_hipPosIncx = 0;
// 			m_hipPosIncy = 0;
// 			m_hipPosIncz = 0;
// 		}
// 		if (m_bonepos[18].y() < m_bonepos[22].y())//wxg 20150630
// 		{
// 			hpos._v[1] -= m_bonepos[18].y() - m_inileftfpos.y();
// 		}
// 		else
// 		{
// 			hpos._v[1] -= m_bonepos[22].y() - m_inileftfpos.y();
// 		}
// 		for (int i=0; i<BONENUM; i++)
// 		{
// 			m_bonepos[i].set(hpos.x(), hpos.y(), hpos.z());//更新根节点位置
// 			nseg = i;
// 			while (nseg != 0)
// 			{
// 				m_bonepos[i] += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);//更新位移信息
// 				nseg = m_parentbone[nseg];
// 			}
// 		}
// 	}
// 	m_segment[23].set(hpos.x() - hipspos.x(), hpos.y() - hipspos.y(), hpos.z() - hipspos.z(), 0);//根节点偏移 maya才用，已注去
// 	//m_segment[23].set(hpos.x(), hpos.y(), hpos.z(), 0);
// 	//hipspos = hpos;
// }

/*void Sender::calcPosition(bool cali)
{
	static osg::Vec3f hipspeed(0.0, 0.0, 0.0);
	int nseg;
	if (cali)
	{
		for (int i=0; i<BONENUM; i++)
		{
			m_bonepos[i].set(m_bonepos[0].x(), m_bonepos[0].y(), m_bonepos[0].z());
			nseg = i;
			while (nseg != 0)
			{
				m_bonepos[i] += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);
				nseg = m_parentbone[nseg];
			}
		}
		hipspeed.set(0.0, 0.0, 0.0);
		return;
	}
	if (!m_calihavedone)
		return;
	osg::Vec3f hippos;
	if (m_minmoveflag <= 150)
	{
         osg::Vec3f movelesssegposfromhips(0.0, 0.0, 0.0);
		 int nseg = m_movelessseg;
		 while (nseg != 0)
		 {
			 movelesssegposfromhips += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);
			 nseg = m_parentbone[nseg];
		 }
		 if ((m_movelessseg == 18) || (m_movelessseg == 22))
		 {
			 static double velocity = 0;
			 if (m_premovelessseg != m_movelessseg)
			 {
				 velocity = 0;
			 }
			 else
			 {
				 double ddis;
				 ddis = velocity / 120 + 9.8 /120/120/2;
				 velocity += 9.8/120;
				 if ((m_bonepos[22].y() - m_inileftfpos.y()) <ddis)
					 ddis = m_bonepos[22].y()  - m_inileftfpos.y();

				 if ((m_bonepos[18].y() - m_inileftfpos.y()) < ddis)
					 ddis = m_bonepos[18].y() - m_inileftfpos.y();
				 m_bonepos[m_movelessseg][1] -= ddis;
			 }
		 }
		 hippos = m_bonepos[0];
		 m_bonepos[0] = m_bonepos[m_movelessseg] - movelesssegposfromhips;
		 for (int i=0; i<BONENUM; i++)
		 {
			 m_bonepos[i].set(m_bonepos[0].x(), m_bonepos[0].y(), m_bonepos[0].z());
			 nseg = i;
			 while (nseg != 0)
			 {
				 m_bonepos[i] += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);
				 nseg = m_parentbone[nseg];
			 }
		 }
		 hipspeed = m_bonepos[0] - hippos;
		 hipspeed /= 1.0/110.0; 
	}
	else
	{
         hippos = m_bonepos[0];
         //计算新的hips位移
		 osg::Vec3f hipaddpos;
		 hipaddpos = hipspeed * (1.0/110.0) + osg::Vec3f(0.0, -1.0, 0.0) * (0.5*9.8/110.0/110.0);
		 for (int i=0; i<BONENUM; i++)
		 {
			 float temp = m_inileftfpos.y() - m_bonepos[i].y();
			 if (temp > hipaddpos.y())
				 hipaddpos[1] = temp;
		 }
		 m_bonepos[0] = hippos + hipaddpos;
		 hipspeed += osg::Vec3f(0.0, -1.0, 0.0) * (9.8/110.0);

		 //end
		 for (int i=0; i<BONENUM; i++)
		 {
			 m_bonepos[i].set(m_bonepos[0].x(), m_bonepos[0].y(), m_bonepos[0].z());
			 nseg = i;
			 while (nseg != 0)
			 {
				 m_bonepos[i] += m_segment[m_parentbone[nseg]] * osg::Vec3f(m_bones[nseg].px, m_bones[nseg].py, m_bones[nseg].pz);
				 nseg = m_parentbone[nseg];
			 }
		 }

	}
	m_premovelessseg = m_movelessseg;
	m_segment[23].set(m_bonepos[0].x() - m_inihipspos.x(), m_bonepos[0].y() - m_inihipspos.y(), m_bonepos[0].z() - m_inihipspos.z(), 0);
}*/

void Sender::setRhandAngle(double aangle)
{
    m_rhangle = aangle * 3.1415926 / 180;
}

void Sender::setModel(IModel* model)
{
    m_model = model;
}

void Sender::ceckPiracy(Configuration* config)
{
	//wxg 先去掉限制
	return;

	QSettings* reg = new QSettings(CQREGISTERPATH,  
		QSettings::NativeFormat);
	int fyear, fmonth, fday, lyear, lmonth, lday;
	long long ldate = config->get(CQMAIN, CQLDATE, "0").toLong();
	bool isAvailable = true;
	if (reg->value(QString("%1").arg(ldate)).toString() == QString("%1").arg(ldate))
	{
		PRINTF("___regedit_currentuser_instech:%ld",ldate);
		isAvailable = false;
	}
	else
	{
		if (!qcommon::decode(config->get(CQMAIN, CQFDATE, "0").toLong(), fyear, fmonth, fday))//wxg 算法可能有问题
		{
			PRINTF("___fdata decode failed.");
			isAvailable = false;
		}
		else
		{
			if (!qcommon::decode(config->get(CQMAIN, CQLDATE, "0").toLong(), lyear, lmonth, lday))
			{
				PRINTF("___ldata decode failed.");
				isAvailable = false;
			}
			else
			{
				if (fyear>lyear)
				{
					PRINTF("___fyear>lyear.");
					isAvailable = false;
				}
				else if ((fyear == lyear)&&(fmonth > lmonth))
				{
					PRINTF("___(fyear == lyear)&&(fmonth > lmonth).");
					isAvailable = false;
				}
				else if ((fyear == lyear)&&(fmonth == lmonth)&&(fday > lday))
				{
					PRINTF("___fyear == lyear)&&(fmonth == lmonth)&&(fday > lday).");
					isAvailable = false;
				}
				else
				{
					//获得当前时间
					QDateTime nowTime = QDateTime::currentDateTime();
					int nyear, nmonth, nday;
					nowTime.date().getDate(&nyear, &nmonth, &nday);
					//与上次的时间比较
					if (nyear < fyear)
					{
						PRINTF("___nyear < fyear(cur vs last).");
						isAvailable = false;
					}
					else if ((nyear == fyear)&&(nmonth < fmonth))
					{
						PRINTF("___(nyear == fyear)&&(nmonth < fmonth)(cur vs last).");
						isAvailable = false;
					}
					else if ((nyear == fyear)&&(nmonth == fmonth)&&(nday < fday))
					{
						PRINTF("___(nyear == fyear)&&(nmonth == fmonth)&&(nday < fday)(cur vs last).");
						isAvailable = false;
					}
					else
					{
// 						if (nyear > lyear)//disable by wxg 跨年跨月会有问题
// 							isAvailable = false;
// 						else if ((nyear == lyear)&&(nmonth > lmonth))
// 							isAvailable = false;
// 						else if ((nyear == lyear)&&(nmonth == lmonth)&&(nday > lday))
// 							isAvailable = false;

						//保存当次日期
						config->set(CQMAIN, CQFDATE, QString("%1").arg(qcommon::encode(nyear, nmonth, nday)));
						TCHAR filename[MAX_PATH];
						if (qcommon::GetExePath(filename))
						{
							_tcscat(filename, _T(CQSETTINGPATH));
							QString fn = filename;
							config->flush(fn);
						}

					}

				}
			}

		}
	}
	if (!isAvailable)
	{
		reg->setValue(QString("%1").arg(ldate), QString("%1").arg(ldate));
		QMessageBox::warning(0, QObject::tr("提示"), QObject::tr("软件需要更新才能使用，请联系开发团队！"));
		delete reg;
		//退出程序
		exit(0);
	}
	delete reg;
}

//void Sender::PrintLog( const char* pMsg )
//{
//	if(m_model)
//		m_model->PrintLog(pMsg);
//}